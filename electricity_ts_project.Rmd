---
title: "Electricity Time Series Project"
output: html_document
date: "2023-05-06"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

path <- "/Users/alisonwong/git/electricity-time-series"
knitr::opts_knit$set(root.dir = path)
setwd(path)

# Load Packages 
library(tidyverse)
library(latex2exp)
library(forecast)
library(tidyverse)
library(tseries)
```

# Read in data and perform data cleaning and wrangling 
```{r}
# Read data 
energy <- read.csv("energy-ca.csv")

# Subset data to select columns we need: Year, Month, State, Megawatts (sold)
energy_df <- subset(energy, select = c("X", "X.1", "X.2", "X.16"))
energy_df <- energy_df[-c(1,2),] # remove first two rows (unnecessary as these rows were the result of a small issue when importing the file)

# Add column names
colnames(energy_df) <- c("Year", "Month", "State", "Megawatts")
table(grepl("CA", energy_df$State)) # check the amount of times in which "CA" appears in the "X.2" column which corresponds to the respective state

# Subset data to select California 
energy_df <- energy_df[energy_df$State == "CA",]

# Get rid of empty rows
row.names(energy_df) <- NULL

# Check the amount of times in which the State column equals "CA". Since this number, 158, matches with the earlier number, we have support to say no important data was lost
table(grepl("CA", energy_df$State))
```

# Arrange data to create a time series object
```{r}
# Change to integers
energy_df$Year <- as.integer(energy_df$Year)
energy_df$Month <- as.integer(energy_df$Month)
energy_df$Megawatts <- as.integer(gsub(",", "", energy_df$Megawatts))

# Arrange energy_df in ascending order of time
energy_df <- energy_df %>%
  arrange(Year, Month)
head(energy_df)

# Remove the 2023 year as only Jan and Feb data is present
energy_df <- energy_df[energy_df$Year != 2023,]

# Time series model 
energy_ts <- ts(energy_df[,4], start= 2010, frequency = 12)
ts.plot(energy_ts, 
        main = "Electricity (Megawatts) Sold with Yearly Average", 
        xlab = "Year", 
        ylab = "Electricity Sold in Megawatts")
```

# Perform time series analysis

Compute yearly average $\hat m_j$ over all months a $\hat m_j=\frac{1}{12}\sum_{k=1}^{12}x_{j,k}$ and eliminate the yearly trend
```{r}
# Get overall trend by moving average window of 12
m_t <- ma(energy_ts, order = 12, centre = T)
ts.plot(energy_ts,
        xlab = "Year",
        ylab = "Electricity Sold in Megawatts",
        main = "Electricity (Megawatts) Sold with Yearly Average")

# Overall trend
ts.plot(m_t,
        xlab = "Year",
        ylab = "Electricity Sold in Megawatts",
        main = "Overall Trend")

# Detrend only
detrend <- energy_ts - m_t
```
We performed a two-sided moving average because (don't know)

Seasonality
```{r}
# Plot new time series that clearly exposes seasonality
ts.plot(detrend,
        xlab = "Year",
        ylab = "Electricity Sold in Megawatts",
        main = "Electricity Sold (Megawatts) after Detrending")

# Get seasonality from detrended time series
s_t <- t(matrix(data = detrend, nrow = 12))

# Monthly seasonality: use matrix of 12 rows
s_t <- colMeans(s_t, na.rm = T)
ts.plot(rep(s_t,12), xlab = "Year", ylab = "Electricity Sold in Megawatts", main = "Seasonality")
```



# Analyze residuals
```{r}
# Decomposed time series by detrending and deseasonalizing
# Extract white noise
z_t <- energy_ts - m_t - s_t
ts.plot(z_t, xlab = "Year", ylab = "Electricity Sold in Megawatts", main = "Residual plot")

# Plot time series, ACF, histogram, QQ-plot of white noise
checkresiduals(z_t)
qqnorm(z_t)
qqline(z_t, col = "red")

# ADF test
adf.test(z_t[7:150]) # since we used the two-sided MA, the first 6 and last 6 points are NA
```
Since the p-value is smaller than 0.05, we reject the null hypothesis and conclude that our residuals are stationary. 

# Analyze the “rough” component

Compute ACF of the time series
```{r}
acf(energy_ts, lag = length(energy_ts) - 1) # not sure why the x axis is wrong
acf <- acf(energy_ts,plot=FALSE)$acf
acf

checkresiduals(energy_ts)
```
The ACF of the time series tails off, meaning that it is likely not a MA(q) process. We will compute and plot PACF to check if the model fits an AR(p) process.

Compute PACF of the time series
```{r}
pacf(energy_ts, lag = length(energy_ts) - 1) # not sure why the x axis is wrong

pacf <- pacf(energy_ts, plot=FALSE)
pacf

model <- ar(energy_ts, order.max=30)
model
```
ar() function returned an AR(12) model, which is reasonable to us. 

# Fit ARMA Model
```{r}
#ar.yw(energy_ts, order = 12)
# For a given time series x we can fit the autoregressive (AR) model using the arima() command and setting order equal to c(1, 0, 0). Note for reference that an AR model is an ARIMA(1, 0, 0) model.
#Fitting the AR Model to the time series
AR <- arima(energy_ts, order = c(11,0,0))
print(AR)

#plotting the series along with the fitted values
ts.plot(energy_ts)
AR_fit <- energy_ts - residuals(AR)
points(AR_fit, type = "l", col = 2, lty = 2)


```

# Predict future values
```{r}
#Using predict() to make a 1-step forecast
predict_AR <- predict(AR, n.ahead = 12)

#Obtaining the 1-step forecast using $pred[1]
predict_AR

#plotting the AirPassenger series plus the forecast and 95% prediction intervals
ts.plot(energy_ts, xlim = c(2010, 2024))
AR_forecast <- predict_AR$pred
AR_forecast_se <- predict_AR$se
points(AR_forecast, type = "l", col = 2)
points(AR_forecast - 2*AR_forecast_se, type = "l", col = "blue", lty = 2)
points(AR_forecast + 2*AR_forecast_se, type = "l", col = "blue", lty = 2)
```

```{r}
# subset 2010 to 2021 to predict 2022 to see the difference 
# Remove the 2023 year as only Jan and Feb data is present
energytest <- energy_df[energy_df$Year != 2023 & energy_df$Year != 2022,]

# Time series model 
energytest_ts <- ts(energytest[,4], start= 2010, frequency = 12)
ts.plot(energytest_ts, xlim = c(2010, 2023))
AR_2022 <- predict(AR, n.past = 1)
points(AR_2022$pred, type = "l", col = 2)
points(AR_2022$pred - 2*AR_2022$se, type = "l", col = "blue", lty = 2)
points(AR_2022$pred + 2*AR_2022$se, type = "l", col = "blue", lty = 2)
``` 


# Spectral Analysis
```{r}
spectrum()


```





